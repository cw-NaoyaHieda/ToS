---
title: "市場リスク評価_"
author: "Naoya Hieda"
date: "2018-02-09"
output:
  rmdformats::readthedown:
    highlight: kate
    number_sections: yes
    css: "toc.css"
    toc_depth: 2
    pandoc_args: [
        "--from", "markdown+autolink_bare_uris+tex_math_single_backslash-implicit_figures"
        ]
---


```{r knitr_init, echo=FALSE, cache=FALSE}
library(knitr)
library(rmdformats)

## Global options
options(max.print="75")
opts_chunk$set(echo=TRUE,
	             prompt=FALSE,
               tidy=TRUE,
               comment=NA,
               message=FALSE,
               warning=FALSE,
               fig.width=6,
               fig.height=4)
opts_knit$set(width=75)
set.seed(2017)
```


```{r package}
#実験で使う関数
source("script/functions.R")
source("script/functions_rolling.R")
objects()
#パッケージのインストールと読み込み
#持ってないパッケージはインストールする
targetPackages <- c('zoo', 'xts','Quandl',
                    'quantmod','ggplot2','grid',"reshape2",'scales',
                    'dplyr','moments','xtable','gridExtra','snow',
                    'parallel',"doParallel") 
newPackages <- targetPackages[!(targetPackages %in% installed.packages()[,"Package"])]
if(length(newPackages)) install.packages(newPackages, repos = "http://cran.us.r-project.org")
for(package in targetPackages) library(package, character.only = T)
```


# 株価収益率の分析

```{r n225}
#データの読み込み
n225 <- read.csv("data/nky.csv",header=TRUE,skip=4)
y <- NULL
#終値(1日の最後の値段)を使う
y$Close <- n225$PX_LAST
#日付データをDate型に変換
y$ymd <- as.POSIXct(n225$Date)
#データフレームにする(行列の列に名前がついているもの)
#ggplotはdata.frameのデータにしか使えないので注意
df <-data.frame(dt=y$ymd, x=y$Close)
```

## 日経225<br>平均株価指数の遷移

```{r n225plot}
#ggplotで日経平均株価をplot
#ggplotの各関数の意味は自分で調べること
ggplot(df,aes(x=dt,y=x))+geom_line()+
        scale_x_datetime(breaks = date_breaks("6 months"))+
        labs(x="Date",y="N225")+
        theme_bw()

```

## 日経平均の<br>対数収益率の推移

```{r n225logplot}
#日経平均の対数収益率をplot
df$log_x <- c(NA,diff(log(df$x))*100)
ggplot(df[-1,],aes(dt,log_x))+geom_line()+
        scale_x_datetime(breaks = date_breaks("6 months"))+
        labs(x="Date",y="log return")+
        theme_bw()+
        theme(strip.background = element_blank(),
              panel.border = element_rect(colour = "black"))
```


## 基礎統計量

```{r fs}
summary(df)
dim(df)
str(df)
```

# VaR,ESのローリング推定

ちなみに、パラメータ推定において、1時点前のデータを使う必要があるため、並列のさせ方を変更しています。

```{r rollingB,eval=FALSE}
IS.fa.outs <- c()
IS.norm.outs <- c()
SMC.fa.outs <- c()
SMC.norm.outs <- c()

cl <- makeCluster(detectCores()-1)  # クラスタの作成
registerDoParallel(cl)
cl_l <- detectCores()-1
clusterExport(cl,list("s_inverse","dfas","dfas2","Cf","Sf","cl_l","rfa_SIR","Resample1"))
result <- c()
for(i in 2:(length(df$log_x)-249)){
  rt <- df$log_x[i:(i+249)]
  rt <- rt[rt!=0]
  
  first_parameter <- c(0, log(0.2), -0.2, 0.5)
  if(i != 2){
    first_parameter <- old_parameter
  }
  fit <- mle.dfas2(rt, ini=first_parameter)
  clusterExport(cl,list("fit"))
  rand.fa<-rfa_SIR_para(n=10000, mu=fit$par2[1],
                        sigma = fit$par2[2],
                        lambda = fit$par2[3],
                        delta = fit$par2[4])
  #真値計算?
  #99%,97.5%,95%の各点に対して，先ほどの関数を用いて求める
  VaR1.fa <- qfas(0.01, mu=fit$par2[1], sigma=fit$par2[2],
                  lambda=fit$par2[3], delta = fit$par2[4])
  VaR25.fa <- qfas(0.025, mu=fit$par2[1], sigma=fit$par2[2],
                   lambda=fit$par2[3], delta = fit$par2[4])
  VaR5.fa <- qfas(0.05, mu=fit$par2[1], sigma=fit$par2[2],
                  lambda=fit$par2[3], delta = fit$par2[4])
  VaR.true.FA <- c(VaR1.fa ,VaR25.fa ,VaR5.fa )
  clusterExport(cl,list("VaR.true.FA"))
  #単純モンテカルロ
  SMC.fa.out <- SMC.fa_para_pre(fit$par2)
  
  #--------------
  
  # 99%,97.5%,95%それぞれのVaRと平均が一致するthetaを取得
  theta.val1<- find.theta(0.01, fit$par2)
  theta.val25<- find.theta(0.025, fit$par2)
  theta.val5<- find.theta(0.05, fit$par2)
  rfa.IS.1<-rIS_SIR_para(n=20000, par=fit$par2, par2=VaR.true.FA[1], theta=theta.val1)
  rfa.IS.25<-rIS_SIR_para(n=20000, par=fit$par2, par2=VaR.true.FA[2], theta=theta.val25)
  rfa.IS.5<-rIS_SIR_para(n=20000, par=fit$par2, par2=VaR.true.FA[3], theta=theta.val5)
  # サンプリングしたものを入力としてFA分布の重点サンプリングを行う
  rfa1 <- sample(rfa.IS.1$q, 10000)
  rfa25 <- sample(rfa.IS.25$q, 10000)
  rfa5 <- sample(rfa.IS.5$q, 10000)
  #clusterExport(cl,list("rfa1","rfa25","rfa5"))
  IS.fa.out <- NULL
  #重点サンプリング
  while(is.null(IS.fa.out)){
    try(IS.fa.out <- IS.fa_pre())
  }
  
  #-------
  theta <- c(mean(rt), sd(rt))
  
  SMC.norm.out <- SMC.norm_pre(theta)
  IS.norm.out <- IS.norm_pre(theta)
  
  #IS.fa.outs <- rbind(IS.fa.outs,IS.fa.out)
  #IS.norm.outs <- rbind(IS.norm.outs,IS.norm.out)
  #SMC.fa.outs <- rbind(SMC.fa.outs,SMC.fa.out)
  #SMC.norm.outs <- rbind(SMC.norm.outs,SMC.norm.out)
  print(i)
  result <- rbind(result,
                   c(i, IS.fa.out,IS.norm.out,SMC.fa.out,SMC.norm.out,
                     fit$par2,mean(rt), sd(rt)))
  old_parameter <- fit$par2
}

stopCluster(cl)
save(list=c("result"),file="data/rolling_result_useoldpara.Rdata")
```


```{r}
load("data/rolling_result_useoldpara.Rdata")
colnames(result) <- c("dt",
                      "IS_VaR_fa_0.01","IS_ES_fa_0.01",
                      "IS_VaR_fa_0.025","IS_ES_fa_0.025",
                      "IS_VaR_fa_0.05","IS_ES_fa_0.05",
                      "IS_VaR_norm_0.01","IS_ES_norm_0.01",
                      "IS_VaR_norm_0.025","IS_ES_norm_0.025",
                      "IS_VaR_norm_0.05","IS_ES_norm_0.05",
                      "SMC_VaR_fa_0.01","SMC_VaR_fa_0.025","SMC_VaR_fa_0.05",
                      "SMC_ES_fa_0.01","SMC_ES_fa_0.025","SMC_ES_fa_0.05",
                      "SMC_VaR_norm_0.01","SMC_VaR_norm_0.025","SMC_VaR_norm_0.05",
                      "SMC_ES_norm_0.01","SMC_ES_norm_0.025","SMC_ES_norm_0.05",
                      "mu","sigma","lambda","delta","mean(rt)","sd(rt)")

result_VaR <- result[,c(1,2,4,6,8,10,12,14,15,16,20,21,22)] %>% data.frame()

result_ES <- result[,c(1,3,5,7,9,11,13,17,18,19,23,24,25)]  %>% data.frame()

result_para <- result[,c(1,26,27,28,29,30,31)]  %>% data.frame()
```

```{r plot}
result_VaR$dt <- df$dt[c(251:length(df$dt))]
result_ES$dt <- df$dt[c(251:length(df$dt))]
result_para$dt <- df$dt[c(251:length(df$dt))]
plot_VaR <- result_VaR %>% data.frame() %>% melt(id="dt")
plot_ES <- result_ES %>% data.frame() %>% melt(id="dt")
plot_para <- result_para %>% data.frame() %>% melt(id="dt")

plot_VaR$level <- apply(plot_VaR,1,function(x) substr(x["variable"],
                                    regexpr("0.0", x["variable"]),
                                    nchar(x["variable"])))

plot_VaR$method <- apply(plot_VaR,1,function(x)
  paste(strsplit(x["variable"][1] %>% as.character(),"_")[[1]][1],
             strsplit(x["variable"] %>% as.character(),"_")[[1]][3])
  )


plot_ES$level <- apply(plot_ES,1,function(x) substr(x["variable"],
                                    regexpr("0.0", x["variable"]),
                                    nchar(x["variable"])))

plot_ES$method <- apply(plot_ES,1,function(x)
  paste(strsplit(x["variable"][1] %>% as.character(),"_")[[1]][1],
             strsplit(x["variable"] %>% as.character(),"_")[[1]][3])
  )

ggplot() +
  geom_line(data=plot_VaR,
    aes(x=dt,y=value,colour=method)) +
  geom_line(data=df[c(252:length(df$dt)),],
            aes(x=dt,y=log_x))+
  facet_grid(level~.,scales = "free")+
  theme_bw()+
  ggtitle("VaR and log return")

ggplot() +
  geom_line(data=plot_VaR,
    aes(x=dt,y=-value,colour=method)) +
  facet_grid(level~.,scales = "free")+
  theme_bw()+
  ggtitle("VaR")

ggplot(plot_ES) +
  geom_line(aes(x=dt,y=-value,colour=method))+
  theme_bw()+
  facet_grid(level~.,scales = "free")+
  ggtitle("ES")
```

## 評価

```{r check}
#VaR
check_VaR <- apply(data.frame(df$log_x[251:length(df$log_x)], -result_VaR[,-1]), 1,
      function(x) x[1] > x[-1]) %>% t()

count_VaR <- colSums(check_VaR)
print("Check count over Estimate VaR")
count_VaR/ dim(check_VaR)[1]

#ES?
eval_ES <- check_VaR * apply(result_ES[,-1],2,function(x) abs(df$log_x[c(251:length(df$dt))] - x)/ -x)

colMeans(eval_ES)
```



## パラメータについて

```{r}
ggplot(plot_para) +
  geom_line(aes(x=dt,y=value,color=variable))+
  theme_bw()+
  facet_grid(variable~.,scales = "free")+
  ggtitle("parameters")+
  guides(colour=FALSE)
```


やはり、deltaが急変してしまう点がある。  
一応はいつなのか確認。
```{r}
result_para %>% mutate(diff_delta = c(diff(delta),0)) %>% 
  filter(diff_delta == diff_delta %>% max())
#sigmaでも一緒
result_para %>% mutate(diff_sigma = c(diff(sigma),0)) %>% 
  filter(diff_sigma == diff_sigma %>% max())
```

前回と一緒。

この日の株価が急変化しているかというと
```{r}
df[df$dt == "2017-11-14",]
```
そんなことはないので、推定に使用する範囲じゃなくなったデータを確認すると
```{r}
df[704-250,]
```
一応納得。

# ロケーションシフト

```{r, eval=FALSE}
IS.fa.outs <- c()
IS.norm.outs <- c()
SMC.fa.outs <- c()
SMC.norm.outs <- c()

cl <- makeCluster(detectCores()-1)  # クラスタの作成
registerDoParallel(cl)
cl_l <- detectCores()-1
clusterExport(cl,list("s_inverse","dfas","dfas2","Cf","Sf",
                      "cl_l","rfa_SIR","Resample1"))
result2 <- c()
result2<-foreach(i = 2:(length(df$log_x)-249), .combine='cbind') %dopar% {
  rt <- df$log_x[i:(i+249)]
  rt <- rt[rt!=0]
  #パラメータ推定の結果は、先ほどのものを使い回す。
  para <- c(result[i-1, c("mu","sigma","lambda","delta")])
  
  #真値計算?
  #99%,97.5%,95%の各点に対して，先ほどの関数を用いて求める
  VaR1.fa <- qfas(0.01, mu=para[1], sigma= para[2],
                  lambda=para[3], delta = para[4])
  VaR25.fa <- qfas(0.025, mu=para[1], sigma=para[2],
                   lambda=para[3], delta = para[4])
  VaR5.fa <- qfas(0.05, mu=para[1], sigma=para[2],
                  lambda=para[3], delta = para[4])
  VaR.true.FA <- c(VaR1.fa ,VaR25.fa ,VaR5.fa )
  
  # 99%,97.5%,95%それぞれのVaRと平均が一致するthetaを取得
  theta.val1<- find.theta(0.01, para)
  theta.val25<- find.theta(0.025, para)
  theta.val5<- find.theta(0.05, para)
  rfa.IS.1<-rIS_SIR(n=20000, par=c(VaR.true.FA[1], para[2:4]), par2=VaR.true.FA[1], theta=theta.val1)
  rfa.IS.25<-rIS_SIR(n=20000, par=c(VaR.true.FA[2], para[2:4]), par2=VaR.true.FA[2], theta=theta.val25)
  rfa.IS.5<-rIS_SIR(n=20000, par=c(VaR.true.FA[3], para[2:4]), par2=VaR.true.FA[3], theta=theta.val5)
  # サンプリングしたものを入力としてFA分布の重点サンプリングを行う
  rfa1 <- sample(rfa.IS.1$q, 10000)
  rfa25 <- sample(rfa.IS.25$q, 10000)
  rfa5 <- sample(rfa.IS.5$q, 10000)
  #clusterExport(cl,list("rfa1","rfa25","rfa5"))
  IS.fa.out <- NULL
  #重点サンプリング
  while(is.null(IS.fa.out)){
    try(IS.fa.out <- IS.fa_pre())
  }
  
  
  c(i, IS.fa.out, VaR.true.FA)
}

stopCluster(cl)
save(list=c("result2"),file="data/rolling_result_locationshift.Rdata")

```

```{r}
load("data/rolling_result_locationshift.Rdata")
result2 <- t(result2)
colnames(result2) <- c("dt",
                      "IS_VaR_fa_0.01","IS_ES_fa_0.01",
                      "IS_VaR_fa_0.025","IS_ES_fa_0.025",
                      "IS_VaR_fa_0.05","IS_ES_fa_0.05",
                      "VaR.01","VaR.025","VaR.05")

result2_VaR <- result2[,c(1,2,4,6)] %>% data.frame()

result2_ES <- result2[,c(1,3,5,7)]  %>% data.frame()

result2_para <- result2[,c(1, 8, 9, 10)]  %>% data.frame()
```

```{r plot2}
result2_VaR$dt <- df$dt[c(251:length(df$dt))]
result2_ES$dt <- df$dt[c(251:length(df$dt))]
result2_para$dt <- df$dt[c(251:length(df$dt))]
plot2_VaR <- result2_VaR %>% data.frame() %>% melt(id="dt")
plot2_ES <- result2_ES %>% data.frame() %>% melt(id="dt")
plot2_para <- result2_para %>% data.frame() %>% melt(id="dt")

plot2_VaR$level <- apply(plot2_VaR,1,function(x) substr(x["variable"],
                                    regexpr("0.0", x["variable"]),
                                    nchar(x["variable"])))

plot2_VaR$method <- apply(plot2_VaR,1,function(x)
  paste(strsplit(x["variable"][1] %>% as.character(),"_")[[1]][1],
             strsplit(x["variable"] %>% as.character(),"_")[[1]][3]," location shift")
  )


plot2_ES$level <- apply(plot2_ES,1,function(x) substr(x["variable"],
                                    regexpr("0.0", x["variable"]),
                                    nchar(x["variable"])))

plot2_ES$method <- apply(plot2_ES,1,function(x)
  paste(strsplit(x["variable"][1] %>% as.character(),"_")[[1]][1],
             strsplit(x["variable"] %>% as.character(),"_")[[1]][3]," location shift")
  )

ggplot() +
  geom_line(data=plot2_VaR,
    aes(x=dt,y=value,colour=method)) +
  geom_line(data=plot_VaR,
    aes(x=dt,y=value,colour=method)) +
  geom_line(data=df[c(252:length(df$dt)),],
            aes(x=dt,y=log_x))+
  facet_grid(level~.,scales = "free")+
  theme_bw()+
  ggtitle("VaR and log return")

ggplot() +
  geom_line(data=plot2_VaR,
    aes(x=dt,y=-value,colour=method)) +
  geom_line(data=plot_VaR,
    aes(x=dt,y=-value,colour=method)) +
  facet_grid(level~.,scales = "free")+
  theme_bw()+
  ggtitle("VaR")

ggplot() +
  geom_line(data = plot2_ES,aes(x=dt,y=-value,colour=method))+
  geom_line(data = plot_ES,aes(x=dt,y=-value,colour=method))+
  theme_bw()+
  facet_grid(level~.,scales = "free")+
  ggtitle("ES")
```

わかりずらいので、対応するものだけ並べる


```{r}
ggplot() +
  geom_line(data=plot2_VaR,
    aes(x=dt,y=value,colour=method)) +
  geom_line(data=plot_VaR %>% filter(method == "IS fa"),
    aes(x=dt,y=value,colour=method)) +
  geom_line(data=df[c(252:length(df$dt)),],
            aes(x=dt,y=log_x))+
  facet_grid(level~.,scales = "free")+
  theme_bw()+
  ggtitle("VaR and log return")

ggplot() +
  geom_line(data=plot2_VaR,
    aes(x=dt,y=-value,colour=method)) +
  geom_line(data=plot_VaR %>% filter(method == "IS fa"),
    aes(x=dt,y=-value,colour=method)) +
  facet_grid(level~.,scales = "free")+
  theme_bw()+
  ggtitle("VaR")

ggplot() +
  geom_line(data = plot2_ES,aes(x=dt,y=-value,colour=method))+
  geom_line(data = plot_ES %>% filter(method == "IS fa"),aes(x=dt,y=-value,colour=method))+
  theme_bw()+
  facet_grid(level~.,scales = "free")+
  ggtitle("ES")
```

ちょっと怪しいですね・・・

## 評価

```{r check2}
#VaR
check2_VaR <- apply(data.frame(df$log_x[251:length(df$log_x)], -result2_VaR[,-1]), 1,
      function(x) x[1] > x[-1]) %>% t()

count2_VaR <- colSums(check2_VaR)
print("Check count over Estimate VaR")
```

```{r}
count2_VaR/ dim(check2_VaR)[1]
```

普通のと比較
```{r}
count_VaR/ dim(check_VaR)[1]
```

全く一緒でした・・・

```{r}
#ES?
eval2_ES <- check2_VaR * apply(result2_ES[,-1],2,function(x) abs(df$log_x[c(251:length(df$dt))] - x)/ -x)

colMeans(eval2_ES)
```