---
title: "市場リスク評価_"
author: "Naoya Hieda"
date: "2018-02-09"
output:
  rmdformats::readthedown:
    highlight: kate
    number_sections: yes
    css: "toc.css"
    toc_depth: 2
    pandoc_args: [
        "--from", "markdown+autolink_bare_uris+tex_math_single_backslash-implicit_figures"
        ]
---


```{r knitr_init, echo=FALSE, cache=FALSE}
library(knitr)
library(rmdformats)

## Global options
options(max.print="75")
opts_chunk$set(echo=TRUE,
	             prompt=FALSE,
               tidy=TRUE,
               comment=NA,
               message=FALSE,
               warning=FALSE,
               fig.width=6,
               fig.height=4)
opts_knit$set(width=75)
set.seed(2017)
```


```{r package}
#実験で使う関数
source("script/functions.R")
source("script/funcitons_prediction.R")
objects()
#パッケージのインストールと読み込み
#持ってないパッケージはインストールする
targetPackages <- c('zoo', 'xts','Quandl',
                    'quantmod','ggplot2','grid',"reshape2",'scales',
                    'dplyr','moments','xtable','gridExtra','snow',
                    'parallel',"doParallel") 
newPackages <- targetPackages[!(targetPackages %in% installed.packages()[,"Package"])]
if(length(newPackages)) install.packages(newPackages, repos = "http://cran.us.r-project.org")
for(package in targetPackages) library(package, character.only = T)
```


# 株価収益率の分析

```{r n225}
#データの読み込み
n225 <- read.csv("data/nky.csv",header=TRUE,skip=4)
y <- NULL
#終値(1日の最後の値段)を使う
y$Close <- n225$PX_LAST
#日付データをDate型に変換
y$ymd <- as.POSIXct(n225$Date)
#データフレームにする(行列の列に名前がついているもの)
#ggplotはdata.frameのデータにしか使えないので注意
df <-data.frame(dt=y$ymd, x=y$Close)
```

## 日経225<br>平均株価指数の遷移

```{r n225plot}
#ggplotで日経平均株価をplot
#ggplotの各関数の意味は自分で調べること
ggplot(df,aes(x=dt,y=x))+geom_line()+
        scale_x_datetime(breaks = date_breaks("6 months"))+
        labs(x="Date",y="N225")+
        theme_bw()

dev.copy2eps(file="plot/n225_20180209.eps")
```

## 日経平均の<br>対数収益率の推移

```{r n225logplot}
#日経平均の対数収益率をplot
df$log_x <- c(NA,diff(log(df$x))*100)
ggplot(df[-1,],aes(dt,log_x))+geom_line()+
        scale_x_datetime(breaks = date_breaks("6 months"))+
        labs(x="Date",y="log return")+
        theme_bw()+
        theme(strip.background = element_blank(),
              panel.border = element_rect(colour = "black"))

dev.copy2eps(file="plot/logreturn_20180209.eps")
```


## 基礎統計量

```{r fs}
summary(df)
dim(df)
str(df)
```



# VaR,ESのローリング推定


```{r rollingB,eval=FALSE}
cl <- makeCluster(detectCores()-1)  # クラスタの作成
registerDoParallel(cl)  
result<-foreach(i = 2:(length(df$log_x)-249), .combine='cbind') %dopar% {
  rt <- df$log_x[i:(i+249)]
  rt <- rt[rt!=0]
  fit <- mle.dfas2(rt, ini=c(0, log(0.2), -0.2, 0.5))
  rand.fa<-rfa_SIR(n=10000, mu=fit$par2[1],
                   sigma = fit$par2[2],
                   lambda = fit$par2[3],
                   delta = fit$par2[4])
  #真値計算?
  #99%,97.5%,95%の各点に対して，先ほどの関数を用いて求める
  VaR1.fa <- qfas(0.01, mu=fit$par2[1], sigma=fit$par2[2],
                  lambda=fit$par2[3], delta = fit$par2[4])
  VaR25.fa <- qfas(0.025, mu=fit$par2[1], sigma=fit$par2[2],
                   lambda=fit$par2[3], delta = fit$par2[4])
  VaR5.fa <- qfas(0.05, mu=fit$par2[1], sigma=fit$par2[2],
                  lambda=fit$par2[3], delta = fit$par2[4])
  VaR.true.FA <- c(VaR1.fa ,VaR25.fa ,VaR5.fa )
  #単純モンテカルロ
  SMC.fa.out <- SMC.fa_pre(fit$par2)
  #--------------
  
  # 99%,97.5%,95%それぞれのVaRと平均が一致するthetaを取得
  theta.val1<- find.theta(0.01, fit$par2)
  theta.val25<- find.theta(0.025, fit$par2)
  theta.val5<- find.theta(0.05, fit$par2)
  rfa.IS.1<-rIS_SIR(n=20000, par=fit$par2, par2=VaR.true.FA[1], theta=theta.val1)
  rfa.IS.25<-rIS_SIR(n=20000, par=fit$par2, par2=VaR.true.FA[2], theta=theta.val25)
  rfa.IS.5<-rIS_SIR(n=20000, par=fit$par2, par2=VaR.true.FA[3], theta=theta.val5)
  # サンプリングしたものを入力としてFA分布の重点サンプリングを行う
  rfa1 <- sample(rfa.IS.1$q, 10000)
  rfa25 <- sample(rfa.IS.25$q, 10000)
  rfa5 <- sample(rfa.IS.5$q, 10000)
  #clusterExport(cl,list("rfa1","rfa25","rfa5"))
  IS.fa.out <- NULL
  #重点サンプリング
  while(is.null(IS.fa.out)){
    try(IS.fa.out <- IS.fa_pre())
  }
  
  #-------
  theta <- c(mean(rt), sd(rt))
  
  SMC.norm.out <- SMC.norm_pre(theta)
  IS.norm.out <- IS.norm_pre(theta)
  
  
  c(i,IS.fa.out,IS.norm.out,SMC.fa.out,SMC.norm.out)
}

stopCluster(cl)
save(list=ls(), file="data/rolling.Rdata")
```


```{r}
load("data/rolling.Rdata")
result <- t(result)
colnames(result) <- c("dt",
                      "IS_VaR_fa_0.01","IS_ES_fa_0.01",
                      "IS_VaR_fa_0.025","IS_ES_fa_0.025",
                      "IS_VaR_fa_0.05","IS_ES_fa_0.05",
                      "IS_VaR_norm_0.01","IS_ES_norm_0.01",
                      "IS_VaR_norm_0.025","IS_ES_norm_0.025",
                      "IS_VaR_norm_0.05","IS_ES_norm_0.05",
                      "SMC_VaR_fa_0.01","SMC_VaR_fa_0.025","SMC_VaR_fa_0.05",
                      "SMC_ES_fa_0.01","SMC_ES_fa_0.025","SMC_ES_fa_0.05",
                      "SMC_VaR_norm_0.01","SMC_VaR_norm_0.025","SMC_VaR_norm_0.05",
                      "SMC_ES_norm_0.01","SMC_ES_norm_0.025","SMC_ES_norm_0.05")

result_VaR <- result[,c(1,2,4,6,8,10,12,14,15,16,20,21,22)] %>% data.frame()

result_ES <- result[,c(1,3,5,7,9,11,13,17,18,19,23,24,25)]  %>% data.frame()
```

```{r plot}
result_VaR$dt <- df$dt[c(251:length(df$dt))]
result_ES$dt <- df$dt[c(251:length(df$dt))]
plot_VaR <- result_VaR %>% data.frame() %>% melt(id="dt")
plot_ES <- result_ES %>% data.frame() %>% melt(id="dt")

plot_VaR$level <- apply(plot_VaR,1,function(x) substr(x["variable"],
                                    regexpr("0.0", x["variable"]),
                                    nchar(x["variable"])))

plot_VaR$method <- apply(plot_VaR,1,function(x)
  paste(strsplit(x["variable"][1] %>% as.character(),"_")[[1]][1],
             strsplit(x["variable"] %>% as.character(),"_")[[1]][3])
  )


plot_ES$level <- apply(plot_ES,1,function(x) substr(x["variable"],
                                    regexpr("0.0", x["variable"]),
                                    nchar(x["variable"])))

plot_ES$method <- apply(plot_ES,1,function(x)
  paste(strsplit(x["variable"][1] %>% as.character(),"_")[[1]][1],
             strsplit(x["variable"] %>% as.character(),"_")[[1]][3])
  )

ggplot() +
  geom_line(data=plot_VaR,
    aes(x=dt,y=-value,colour=method)) +
  geom_line(data=df[c(252:length(df$dt)),],
            aes(x=dt,y=log_x))+
  facet_grid(level~.,scales = "free")+
  theme_bw()


ggplot(plot_ES) +
  geom_line(aes(x=dt,y=-value,colour=method))+
  theme_bw()+
  facet_grid(level~.,scales = "free")

```

```{r check}
check_VaR <- apply(data.frame(df$log_x[251:length(df$log_x)], -result_VaR[,-1]), 1,
      function(x) x[1] > x[-1]) %>% t()

count_VaR <- colSums(check_VaR)
print("Check count over Estimate VaR")
count_VaR/ dim(check_VaR)[1]

#ES?
colSums(check_VaR * -result_VaR[,-1]) / colSums(check_VaR)
```





## 並列のさせかた別パターン

こっちの方が早いかもしれません

```{r rollingA,eval=FALSE}
IS.fa.outs <- c()
IS.norm.outs <- c()
SMC.fa.outs <- c()
SMC.norm.outs <- c()

cl <- makeCluster(detectCores()-1)  # クラスタの作成
registerDoParallel(cl)  
clusterExport(cl,list("s_inverse","dfas","dfas2","Cf","Sf","cl_l","rfa_SIR","Resample1"))

for(i in 2:(length(df$log_x)-249)){
  rt <- df$log_x[i:(i+249)]
  rt <- rt[rt!=0]
  fit <- mle.dfas2(rt, ini=c(0, log(0.2), -0.2, 0.5))
  clusterExport(cl,list("fit"))
  rand.fa<-rfa_SIR_para(n=10000, mu=fit$par2[1],
                   sigma = fit$par2[2],
                   lambda = fit$par2[3],
                   delta = fit$par2[4])
  #真値計算?
  #99%,97.5%,95%の各点に対して，先ほどの関数を用いて求める
  VaR1.fa <- qfas(0.01, mu=fit$par2[1], sigma=fit$par2[2],
                  lambda=fit$par2[3], delta = fit$par2[4])
  VaR25.fa <- qfas(0.025, mu=fit$par2[1], sigma=fit$par2[2],
                   lambda=fit$par2[3], delta = fit$par2[4])
  VaR5.fa <- qfas(0.05, mu=fit$par2[1], sigma=fit$par2[2],
                  lambda=fit$par2[3], delta = fit$par2[4])
  VaR.true.FA <- c(VaR1.fa ,VaR25.fa ,VaR5.fa )
  #単純モンテカルロ
  SMC.fa.out <- SMC.fa_para_pre(fit$par2)
  
  #--------------
  
  # 99%,97.5%,95%それぞれのVaRと平均が一致するthetaを取得
  theta.val1<- find.theta(0.01, fit$par2)
  theta.val25<- find.theta(0.025, fit$par2)
  theta.val5<- find.theta(0.05, fit$par2)
  clusterExport(cl,list("VaR.true.FA"))
  rfa.IS.1<-rIS_SIR_para(n=20000, par=fit$par2, par2=VaR.true.FA[1], theta=theta.val1)
  rfa.IS.25<-rIS_SIR_para(n=20000, par=fit$par2, par2=VaR.true.FA[2], theta=theta.val25)
  rfa.IS.5<-rIS_SIR_para(n=20000, par=fit$par2, par2=VaR.true.FA[3], theta=theta.val5)
  # サンプリングしたものを入力としてFA分布の重点サンプリングを行う
  rfa1 <- sample(rfa.IS.1$q, 10000)
  rfa25 <- sample(rfa.IS.25$q, 10000)
  rfa5 <- sample(rfa.IS.5$q, 10000)
  #clusterExport(cl,list("rfa1","rfa25","rfa5"))
  IS.fa.out <- NULL
  #重点サンプリング
  while(is.null(IS.fa.out)){
    try(IS.fa.out <- IS.fa_para_pre())
  }
  
  #-------
  theta <- c(mean(rt), sd(rt))
  
  SMC.norm.out <- SMC.norm_pre(theta)
  IS.norm.out <- IS.norm_pre(theta)
  
  #IS.fa.outs <- rbind(IS.fa.outs,IS.fa.out)
  #IS.norm.outs <- rbind(IS.norm.outs,IS.norm.out)
  #SMC.fa.outs <- rbind(SMC.fa.outs,SMC.fa.out)
  #SMC.norm.outs <- rbind(SMC.norm.outs,SMC.norm.out)
  print(i)
  return(IS.fa.out,IS.norm.outSMC.fa.out,SMC.norm.out)
}

stopCluster(cl)

```

